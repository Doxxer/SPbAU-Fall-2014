/**
 * generated by Xtext
 */
package ru.spbau.turaev.depgraph.generator;

import com.google.common.collect.Iterators;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import ru.spbau.turaev.depgraph.myDsl.NoRelationships;
import ru.spbau.turaev.depgraph.myDsl.Person;
import ru.spbau.turaev.depgraph.myDsl.RelationshipDescription;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class MyDslGenerator implements IGenerator {
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterator<Person> _filter = Iterators.<Person>filter(_allContents, Person.class);
    final Function1<Person, CharSequence> _function = new Function1<Person, CharSequence>() {
      public CharSequence apply(final Person it) {
        return MyDslGenerator.this.compile(it);
      }
    };
    Iterator<CharSequence> _map = IteratorExtensions.<Person, CharSequence>map(_filter, _function);
    String _join = IteratorExtensions.join(_map, "\n\n");
    fsa.generateFile("Relationships.java", _join);
  }
  
  protected CharSequence _compile(final Person p) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("class ");
    String _name = p.getName();
    _builder.append(_name, "");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("public List<Class> getDependencies() {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return ");
    EObject _rels = p.getRels();
    Object _compile = this.compile(_rels);
    _builder.append(_compile, "\t\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  protected CharSequence _compile(final NoRelationships rels) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Collections.emptyList()");
    return _builder;
  }
  
  protected CharSequence _compile(final RelationshipDescription rels) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Arrays.asList(");
    EList<Person> _rel = rels.getRel();
    final Function1<Person, String> _function = new Function1<Person, String>() {
      public String apply(final Person it) {
        String _name = it.getName();
        return (_name + ".class");
      }
    };
    List<String> _map = ListExtensions.<Person, String>map(_rel, _function);
    String _join = IterableExtensions.join(_map, ", ");
    _builder.append(_join, "");
    _builder.append(")");
    return _builder;
  }
  
  public CharSequence compile(final EObject rels) {
    if (rels instanceof NoRelationships) {
      return _compile((NoRelationships)rels);
    } else if (rels instanceof Person) {
      return _compile((Person)rels);
    } else if (rels instanceof RelationshipDescription) {
      return _compile((RelationshipDescription)rels);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(rels).toString());
    }
  }
}
